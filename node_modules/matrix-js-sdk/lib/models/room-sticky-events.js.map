{"version":3,"file":"room-sticky-events.js","names":["logger","loggerInstance","TypedEventEmitter","getChild","RoomStickyEventsEvent","RoomStickyEventsStore","constructor","arguments","_defineProperty","Map","Set","Number","MAX_SAFE_INTEGER","now","Date","removedEvents","nextStickyEventExpiryTs","eventType","innerEvents","stickyEventsMap","entries","_this$stickyEventsMap","innerMapKey","event","unstableStickyExpiresAt","debug","getId","push","get","delete","Math","min","size","unkeyedStickyEvents","length","emit","Update","scheduleStickyTimer","getStickyEvents","innerMap","values","getKeyedStickyEvent","sender","type","stickyKey","_this$stickyEventsMap2","concat","getUnkeyedStickyEvent","filter","ev","getType","getSender","addStickyEvent","getContent","msc4354_sticky_key","undefined","Error","info","added","startsWith","prevEvent","_this$stickyEventsMap3","_event$getId","_prevEvent$getId","getTs","has","set","add","addStickyEvents","events","updated","result","current","previous","ex","warn","stickyEventTimer","clearTimeout","setTimeout","cleanExpiredStickyEvents","clear"],"sources":["../../src/models/room-sticky-events.ts"],"sourcesContent":["import { logger as loggerInstance } from \"../logger.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\n\nconst logger = loggerInstance.getChild(\"RoomStickyEvents\");\n\nexport enum RoomStickyEventsEvent {\n    Update = \"RoomStickyEvents.Update\",\n}\n\ntype StickyMatrixEvent = MatrixEvent & { unstableStickyExpiresAt: number };\n\nexport type RoomStickyEventsMap = {\n    /**\n     * Fires when any sticky event changes happen in a room.\n     * @param added Any new sticky events with no predecessor events (matching sender, type, and sticky_key)\n     * @param updated Any sticky events that supersede an existing event (matching sender, type, and sticky_key)\n     * @param removed The events that were removed from the map due to expiry.\n     */\n    [RoomStickyEventsEvent.Update]: (\n        added: StickyMatrixEvent[],\n        updated: { current: StickyMatrixEvent; previous: StickyMatrixEvent }[],\n        removed: StickyMatrixEvent[],\n    ) => void;\n};\n\n/**\n * Tracks sticky events on behalf of one room, and fires an event\n * whenever a sticky event is updated or replaced.\n */\nexport class RoomStickyEventsStore extends TypedEventEmitter<RoomStickyEventsEvent, RoomStickyEventsMap> {\n    private readonly stickyEventsMap = new Map<string, Map<string, StickyMatrixEvent>>(); // (type -> stickyKey+userId) -> event\n    private readonly unkeyedStickyEvents = new Set<StickyMatrixEvent>();\n\n    private stickyEventTimer?: ReturnType<typeof setTimeout>;\n    private nextStickyEventExpiryTs: number = Number.MAX_SAFE_INTEGER;\n\n    /**\n     * Get all sticky events that are currently active.\n     * @returns An iterable set of events.\n     */\n    public *getStickyEvents(): Iterable<StickyMatrixEvent> {\n        yield* this.unkeyedStickyEvents;\n        for (const innerMap of this.stickyEventsMap.values()) {\n            yield* innerMap.values();\n        }\n    }\n\n    /**\n     * Get an active sticky event that match the given `type`, `sender`, and `stickyKey`\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @param stickyKey The sticky key used by the event.\n     * @returns A matching active sticky event, or undefined.\n     */\n    public getKeyedStickyEvent(sender: string, type: string, stickyKey: string): StickyMatrixEvent | undefined {\n        return this.stickyEventsMap.get(type)?.get(`${stickyKey}${sender}`);\n    }\n\n    /**\n     * Get active sticky events without a sticky key that match the given `type` and `sender`.\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @returns An array of matching sticky events.\n     */\n    public getUnkeyedStickyEvent(sender: string, type: string): StickyMatrixEvent[] {\n        return [...this.unkeyedStickyEvents].filter((ev) => ev.getType() === type && ev.getSender() === sender);\n    }\n\n    /**\n     * Adds a sticky event into the local sticky event map.\n     *\n     * NOTE: This will not cause `RoomEvent.StickyEvents` to be emitted.\n     *\n     * @throws If the `event` does not contain valid sticky data.\n     * @param event The MatrixEvent that contains sticky data.\n     * @returns An object describing whether the event was added to the map,\n     *          and the previous event it may have replaced.\n     */\n    private addStickyEvent(event: MatrixEvent): { added: true; prevEvent?: StickyMatrixEvent } | { added: false } {\n        const stickyKey = event.getContent().msc4354_sticky_key;\n        if (typeof stickyKey !== \"string\" && stickyKey !== undefined) {\n            throw new Error(`${event.getId()} is missing msc4354_sticky_key`);\n        }\n\n        // With this we have the guarantee, that all events in stickyEventsMap are correctly formatted\n        if (event.unstableStickyExpiresAt === undefined) {\n            throw new Error(`${event.getId()} is missing msc4354_sticky.duration_ms`);\n        }\n        const sender = event.getSender();\n        const type = event.getType();\n        if (!sender) {\n            throw new Error(`${event.getId()} is missing a sender`);\n        } else if (event.unstableStickyExpiresAt <= Date.now()) {\n            logger.info(\"ignored sticky event with older expiration time than current time\", stickyKey);\n            return { added: false };\n        }\n\n        // While we fully expect the server to always provide the correct value,\n        // this is just insurance to protect against attacks on our Map.\n        if (!sender.startsWith(\"@\")) {\n            throw new Error(\"Expected sender to start with @\");\n        }\n\n        let prevEvent: StickyMatrixEvent | undefined;\n        if (stickyKey !== undefined) {\n            // Why this is safe:\n            // A type may contain anything but the *sender* is tightly\n            // constrained so that a key will always end with a @<user_id>\n            // E.g. Where a malicous event type might be \"rtc.member.event@foo:bar\" the key becomes:\n            // \"rtc.member.event.@foo:bar@bar:baz\"\n            const innerMapKey = `${stickyKey}${sender}`;\n            prevEvent = this.stickyEventsMap.get(type)?.get(innerMapKey);\n\n            // sticky events are not allowed to expire sooner than their predecessor.\n            if (prevEvent && event.unstableStickyExpiresAt < prevEvent.unstableStickyExpiresAt) {\n                logger.info(\"ignored sticky event with older expiry time\", stickyKey);\n                return { added: false };\n            } else if (\n                prevEvent &&\n                event.getTs() === prevEvent.getTs() &&\n                (event.getId() ?? \"\") < (prevEvent.getId() ?? \"\")\n            ) {\n                // This path is unlikely, as it requires both events to have the same TS.\n                logger.info(\"ignored sticky event due to 'id tie break rule' on sticky_key\", stickyKey);\n                return { added: false };\n            }\n            if (!this.stickyEventsMap.has(type)) {\n                this.stickyEventsMap.set(type, new Map());\n            }\n            this.stickyEventsMap.get(type)!.set(innerMapKey, event as StickyMatrixEvent);\n        } else {\n            this.unkeyedStickyEvents.add(event as StickyMatrixEvent);\n        }\n\n        // Recalculate the next expiry time.\n        this.nextStickyEventExpiryTs = Math.min(event.unstableStickyExpiresAt, this.nextStickyEventExpiryTs);\n\n        this.scheduleStickyTimer();\n        return { added: true, prevEvent };\n    }\n\n    /**\n     * Add a series of sticky events, emitting `RoomEvent.StickyEvents` if any\n     * changes were made.\n     * @param events A set of new sticky events.\n     */\n    public addStickyEvents(events: MatrixEvent[]): void {\n        const added: StickyMatrixEvent[] = [];\n        const updated: { current: StickyMatrixEvent; previous: StickyMatrixEvent }[] = [];\n        for (const event of events) {\n            try {\n                const result = this.addStickyEvent(event);\n                if (result.added) {\n                    if (result.prevEvent) {\n                        // e is validated as a StickyMatrixEvent by virtue of `addStickyEvent` returning added: true.\n                        updated.push({ current: event as StickyMatrixEvent, previous: result.prevEvent });\n                    } else {\n                        added.push(event as StickyMatrixEvent);\n                    }\n                }\n            } catch (ex) {\n                logger.warn(\"ignored invalid sticky event\", ex);\n            }\n        }\n        if (added.length || updated.length) this.emit(RoomStickyEventsEvent.Update, added, updated, []);\n        this.scheduleStickyTimer();\n    }\n\n    /**\n     * Schedule the sticky event expiry timer. The timer will\n     * run immediately if an event has already expired.\n     */\n    private scheduleStickyTimer(): void {\n        if (this.stickyEventTimer) {\n            clearTimeout(this.stickyEventTimer);\n            this.stickyEventTimer = undefined;\n        }\n        if (this.nextStickyEventExpiryTs === Number.MAX_SAFE_INTEGER) {\n            // We have no events due to expire.\n            return;\n        } // otherwise, schedule in the future\n        this.stickyEventTimer = setTimeout(this.cleanExpiredStickyEvents, this.nextStickyEventExpiryTs - Date.now());\n    }\n\n    /**\n     * Clean out any expired sticky events.\n     */\n    private readonly cleanExpiredStickyEvents = (): void => {\n        const now = Date.now();\n        const removedEvents: StickyMatrixEvent[] = [];\n\n        // We will recalculate this as we check all events.\n        this.nextStickyEventExpiryTs = Number.MAX_SAFE_INTEGER;\n        for (const [eventType, innerEvents] of this.stickyEventsMap.entries()) {\n            for (const [innerMapKey, event] of innerEvents) {\n                // we only added items with `sticky` into this map so we can assert non-null here\n                if (now >= event.unstableStickyExpiresAt) {\n                    logger.debug(\"Expiring sticky event\", event.getId());\n                    removedEvents.push(event);\n                    this.stickyEventsMap.get(eventType)!.delete(innerMapKey);\n                } else {\n                    // If not removing the event, check to see if it's the next lowest expiry.\n                    this.nextStickyEventExpiryTs = Math.min(\n                        this.nextStickyEventExpiryTs,\n                        event.unstableStickyExpiresAt,\n                    );\n                }\n            }\n            // Clean up map after use.\n            if (this.stickyEventsMap.get(eventType)?.size === 0) {\n                this.stickyEventsMap.delete(eventType);\n            }\n        }\n        for (const event of this.unkeyedStickyEvents) {\n            if (now >= event.unstableStickyExpiresAt) {\n                logger.debug(\"Expiring sticky event\", event.getId());\n                this.unkeyedStickyEvents.delete(event);\n                removedEvents.push(event);\n            } else {\n                // If not removing the event, check to see if it's the next lowest expiry.\n                this.nextStickyEventExpiryTs = Math.min(this.nextStickyEventExpiryTs, event.unstableStickyExpiresAt);\n            }\n        }\n        if (removedEvents.length) {\n            this.emit(RoomStickyEventsEvent.Update, [], [], removedEvents);\n        }\n        // Finally, schedule the next run.\n        this.scheduleStickyTimer();\n    };\n\n    /**\n     * Clear all events and stop the timer from firing.\n     */\n    public clear(): void {\n        this.stickyEventsMap.clear();\n        // Unschedule timer.\n        this.nextStickyEventExpiryTs = Number.MAX_SAFE_INTEGER;\n        this.scheduleStickyTimer();\n    }\n}\n"],"mappings":"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","ignoreList":[]}